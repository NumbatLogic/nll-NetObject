namespace NumbatLogic
{
	namespace NetObject_BlobPack
	{
		/*<?
			include_once "../../Metaprogramming.php";

			$pOutputArray = array();

			$pObjectChild = new NetObject("Child",
				[
					new NetObjectField("Uint32", "ChildId", false),
					new NetObjectField("string", "Name", false),
				]
			);
			$pOutputArray[] = $pObjectChild;

			$pObjectParent = new NetObject("Parent",
				[
					new NetObjectField("Uint32", "ParentId", false),
					new NetObjectField("Child", "Child", false),
				]
			);
			$pOutputArray[] = $pObjectParent;

			$pFilterParent = new NetObjectFilter("ParentFilter", "Parent", array(
				"TestId" => true,
				"Child" => array(
					"ChildId" => true
				)
			));
			$pOutputArray[] = $pFilterParent;

			NetObject_Output($pOutputArray);
		?>*/
			class ChildInfo : NetObject::Info
			{
				public static ChildInfo __pStatic = null;
				public construct() : base(1, 1, 0, 0)
				{
					Assert::Plz(__pStatic == null);
					__pStatic = this;
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::UINT32, "ChildId", 0));
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::STRING, "Name", 0));
				}
				public destruct() { __pStatic = null; }
				public static ChildInfo GetStatic()
				{
					Assert::Plz(__pStatic != null);
					return __pStatic;
				}
			}

			class Child : NetObject::Object
			{
				public construct(NetObject::Filter pFilter = null) : base(ChildInfo::GetStatic(), pFilter) { }
				public Uint32 GetChildId() { return GetUint32(0); }
				public string GetName() { return GetString(0); }
			}

			class ParentInfo : NetObject::Info
			{
				public static ParentInfo __pStatic = null;
				public construct() : base(1, 0, 1, 0)
				{
					Assert::Plz(__pStatic == null);
					__pStatic = this;
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::UINT32, "ParentId", 0));
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::OBJECT, "Child", 0));
				}
				public destruct() { __pStatic = null; }
				public static ParentInfo GetStatic()
				{
					Assert::Plz(__pStatic != null);
					return __pStatic;
				}
				public override NetObject::Object** __CreateChildObject(int nFieldIndex, NetObject::Filter pFilter)
				{
					switch (nFieldIndex)
					{
						case 1: return new Child();
					}
					Assert::Plz(false);
					return null;
				}
			}

			class Parent : NetObject::Object
			{
				public construct(NetObject::Filter pFilter = null) : base(ParentInfo::GetStatic(), pFilter) { }
				public Uint32 GetParentId() { return GetUint32(0); }
				public Child GetChild() { return cast Child(GetObject(0)); }
			}

			class ParentFilter : NetObject::Filter
			{
				public static ParentFilter __pStatic = null;
				public construct()
				{
					Assert::Plz(__pStatic == null);
					__pStatic = this;
				}
				public destruct() { __pStatic = null; }
			}

			class NetObjectStatic
			{
				public ChildInfo* m_pChildInfo;
				public ParentInfo* m_pParentInfo;
				public ParentFilter* m_pParentFilter;
				public construct()
				{
					m_pChildInfo = own new ChildInfo();
					m_pParentInfo = own new ParentInfo();
					m_pParentFilter = own new ParentFilter();
				}
			}
		/*<??>*/
		
		class Test
		{
			public static void Run()
			{
				NetObjectStatic* pStaticInfo = own new NetObjectStatic();

				Parent* pObjectA = own new Parent();

				Assert::Plz(pObjectA.GetParentId() == 0);
				pObjectA.__pUint32Vector.Set(0, 1234);
				Assert::Plz(pObjectA.GetParentId() == 1234);

				pObjectA.__pObjectVector.Set(0, new Child());
				Child pChild = pObjectA.GetChild();

				Assert::Plz(pChild.GetChildId() == 0);
				pChild.__pUint32Vector.Set(0, 2222);
				Assert::Plz(pChild.GetChildId() == 2222);

				Assert::Plz(ExternalString::Equal(pChild.GetName(), ""));
				pChild.__pStringVector.Set(0, new InternalString("banana"));
				Assert::Plz(ExternalString::Equal(pChild.GetName(), "banana"));

				gsBlob* pBlob = own new gsBlob();
				pObjectA.Pack(pBlob);
				
				pBlob.SetOffset(0);

				Parent* pObjectB = own new Parent();
				Assert::Plz(!pObjectB.IsEqual(pObjectA));
				Assert::Plz(pObjectB.Unpack(pBlob));
				Assert::Plz(pObjectB.IsEqual(pObjectA));

				Parent* pObjectC = own new Parent();
				Assert::Plz(!pObjectC.Unpack(pBlob));
				Assert::Plz(!pObjectC.IsEqual(pObjectA));
			}
		}
	}
} 