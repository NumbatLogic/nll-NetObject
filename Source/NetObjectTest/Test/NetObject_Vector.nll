namespace NumbatLogic
{
	namespace NetObject_Vector
	{
		/*<?
			include_once "../../Metaprogramming.php";

			$pOutputArray = array();

			$pObjectChild = new NetObject("Child",
				[
					new NetObjectField("Uint32", "ChildId"),
					new NetObjectField("string", "Name"),
				]
			);
			$pOutputArray[] = $pObjectChild;

			$pObjectParent = new NetObject("Parent",
				[
					new NetObjectField("Uint32", "ParentId"),
					new NetObjectVectorField("Child", "Spawn", array("ChildId", "Name")),
				]
			);
			$pOutputArray[] = $pObjectParent;

			NetObject_Output($pOutputArray);
		?>*/
			class ChildInfo : NetObject::ObjectInfo
			{
				public static ChildInfo __pStatic = null;
				public construct() : base(1, 1, 0, 0)
				{
					Assert::Plz(__pStatic == null);
					__pStatic = this;
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::UINT32, "ChildId", 0, 0));
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::STRING, "Name", 1, 0));
				}
				public destruct() { __pStatic = null; }
				public static ChildInfo GetStatic() { Assert::Plz(__pStatic != null); return __pStatic; }
			}

			class Child : NetObject::Object
			{
				public construct(NetObject::Filter pFilter = null) : base(ChildInfo::GetStatic(), pFilter) { }
				public Uint32 GetChildId() { return __GetUint32(0, 0); }
				public string GetName() { return __GetString(1, 0); }
			}

			class ParentInfo : NetObject::ObjectInfo
			{
				public static ParentInfo __pStatic = null;
				public construct() : base(1, 0, 0, 1)
				{
					Assert::Plz(__pStatic == null);
					__pStatic = this;
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::UINT32, "ParentId", 0, 0));
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::VECTOR, "Spawn", 1, 0));
				}
				public destruct() { __pStatic = null; }
				public static ParentInfo GetStatic() { Assert::Plz(__pStatic != null); return __pStatic; }
				public override NetObject::Object** __CreateChildObject(int nFieldIndex, NetObject::Filter pFilter)
				{
					switch (nFieldIndex)
					{
						case 1: return new Child();
					}
					Assert::Plz(false);
					return null;
				}
			}

			class Parent : NetObject::Object
			{
				public construct(NetObject::Filter pFilter = null) : base(ParentInfo::GetStatic(), pFilter) { }
				public Uint32 GetParentId() { return __GetUint32(0, 0); }
				public int GetNumSpawn() { return __GetVectorSize(1, 0); }
				public Child GetSpawnByIndex(int nIndex) { return cast Child(__GetVectorObject(1, 0, nIndex)); }
				public Child GetSpawnByChildId(Uint32 nChildId) { return cast Child(__GetVectorObjectByUint32(1, 0, 0, nChildId)); }
				public Child GetSpawnByName(string sName) { return cast Child(__GetVectorObjectByString(1, 0, 0, sName)); }
			}

			class NetObjectStatic
			{
				public NetObject::ChangeMap* __pChangeMap;
				public ChildInfo* m_pChildInfo;
				public ParentInfo* m_pParentInfo;
				public construct()
				{
					__pChangeMap = own new NetObject::ChangeMap();
					m_pChildInfo = own new ChildInfo();
					m_pParentInfo = own new ParentInfo();
				}
			}
		/*<??>*/
		
		class Test
		{
			public static void Run()
			{
				NetObjectStatic* pStaticInfo = own new NetObjectStatic();

				Parent* pObjectA = own new Parent();

				Assert::Plz(pObjectA.GetParentId() == 0);
				pObjectA.__pUint32Vector.Set(0, 1234);
				Assert::Plz(pObjectA.GetParentId() == 1234);

				Assert::Plz(pObjectA.GetNumSpawn() == 0);
				pObjectA.__pVectorVector.Set(0, new OwnedVector<NetObject::Object>());
				Assert::Plz(pObjectA.GetNumSpawn() == 0);
				OwnedVector<NetObject::Object> pVector = pObjectA.__pVectorVector.Get(0);
				
				pVector.PushBack(new Child());
				Assert::Plz(pObjectA.GetNumSpawn() == 1);
				Child pSpawnA = cast Child(pVector.Get(0));
				pSpawnA.__pUint32Vector.Set(0, 2222);
				Assert::Plz(pSpawnA.GetChildId() == 2222);

				pVector.PushBack(new Child());
				Assert::Plz(pObjectA.GetNumSpawn() == 2);
				Child pSpawnB = cast Child(pVector.Get(1));
				pSpawnB.__pUint32Vector.Set(0, 33);
				Assert::Plz(pSpawnB.GetChildId() == 33);
				pSpawnB.__pStringVector.Set(0, new InternalString("banana"));
				Assert::Plz(ExternalString::Equal(pSpawnB.GetName(), "banana"));

				Assert::Plz(pObjectA.GetSpawnByIndex(0) == pSpawnA);
				Assert::Plz(pObjectA.GetSpawnByChildId(2222) == pSpawnA);
				Assert::Plz(pObjectA.GetSpawnByChildId(33) == pSpawnB);
				Assert::Plz(pObjectA.GetSpawnByChildId(69) == null);
				Assert::Plz(pObjectA.GetSpawnByName("") == pSpawnA);
				Assert::Plz(pObjectA.GetSpawnByName("banana") == pSpawnB);
				Assert::Plz(pObjectA.GetSpawnByName("404") == null);

				gsBlob* pBlob = own new gsBlob();
				pObjectA.Pack(pBlob);
				
				pBlob.SetOffset(0);

				Parent* pObjectB = own new Parent();
				Assert::Plz(!pObjectB.IsEqual(pObjectA));
				Assert::Plz(pObjectB.Unpack(pBlob));
				Assert::Plz(pObjectB.IsEqual(pObjectA));

				Parent* pObjectC = own new Parent();
				Assert::Plz(!pObjectC.Unpack(pBlob));
				Assert::Plz(!pObjectC.IsEqual(pObjectA));
			}
		}
	}
} 