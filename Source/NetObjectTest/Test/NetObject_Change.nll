namespace NumbatLogic
{
	namespace NetObject_Change
	{
		/*<?
			include_once "../../Metaprogramming.php";
			
			$pOutputArray = array();

			$pTestChild = new NetObject("TestChild",
				[
					new NetObjectField("Uint32", "TestChildId"),
					new NetObjectField("string", "Name"),
				]
			);
			$pOutputArray[] = $pTestChild;

			$pTestObject = new NetObject("TestObject",
				[
					new NetObjectField("Uint32", "TestId"),
					new NetObjectField("string", "Name"),
					new NetObjectField("Uint32", "Gold"),
					new NetObjectField("TestChild", "SingleChild"),
					new NetObjectVectorField("TestChild", "MultiChild", array("TestChildId", "Name")),
				]
			);
			$pOutputArray[] = $pTestObject;

			NetObject_Output($pOutputArray, true);
		?>*/
			class TestChildInfo : NetObject::ObjectInfo
			{
				public static TestChildInfo __pStatic = null;
				public construct() : base(0, 1, 1, 0, 0)
				{
					Assert::Plz(__pStatic == null);
					__pStatic = this;
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::UINT32, "TestChildId", 0, 0));
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::STRING, "Name", 1, 0));
				}
				public destruct() { __pStatic = null; }
				public static TestChildInfo GetStatic() { Assert::Plz(__pStatic != null); return __pStatic; }
			}

			class TestChild : NetObject::Object
			{
				public construct(NetObject::Filter pFilter = null) : base(TestChildInfo::GetStatic(), pFilter) { }
				public Uint32 GetTestChildId() { return __GetUint32(0, 0); }
				public string GetName() { return __GetString(1, 0); }
			}

			class TestObjectInfo : NetObject::ObjectInfo
			{
				public static TestObjectInfo __pStatic = null;
				public construct() : base(0, 2, 1, 1, 1)
				{
					Assert::Plz(__pStatic == null);
					__pStatic = this;
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::UINT32, "TestId", 0, 0));
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::STRING, "Name", 1, 0));
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::UINT32, "Gold", 2, 1));
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::OBJECT, "SingleChild", 3, 0));
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::VECTOR, "MultiChild", 4, 0));
				}
				public destruct() { __pStatic = null; }
				public static TestObjectInfo GetStatic() { Assert::Plz(__pStatic != null); return __pStatic; }
				public override NetObject::Object** __CreateChildObject(int nFieldIndex, NetObject::Filter pFilter)
				{
					switch (nFieldIndex)
					{
						case 3: return new TestChild();
						case 4: return new TestChild();
					}
					Assert::Plz(false);
					return null;
				}
			}

			class TestObject : NetObject::Object
			{
				public construct(NetObject::Filter pFilter = null) : base(TestObjectInfo::GetStatic(), pFilter) { }
				public Uint32 GetTestId() { return __GetUint32(0, 0); }
				public string GetName() { return __GetString(1, 0); }
				public Uint32 GetGold() { return __GetUint32(2, 1); }
				public TestChild GetSingleChild() { return cast TestChild(__GetObject(3, 0)); }
				public int GetNumMultiChild() { return __GetVectorSize(4, 0); }
				public TestChild GetMultiChildByIndex(int nIndex) { return cast TestChild(__GetVectorObject(4, 0, nIndex)); }
				public TestChild GetMultiChildByTestChildId(Uint32 nTestChildId) { return cast TestChild(__GetVectorObjectByUint32(4, 0, 0, nTestChildId)); }
				public TestChild GetMultiChildByName(string sName) { return cast TestChild(__GetVectorObjectByString(4, 0, 0, sName)); }
			}

			class NetObjectStatic
			{
				public NetObject::ChangeMap* __pChangeMap;
				public TestChildInfo* __pTestChildInfo;
				public TestObjectInfo* __pTestObjectInfo;
				public construct()
				{
					__pChangeMap = own new NetObject::ChangeMap();
					__pTestChildInfo = own new TestChildInfo();
					__pTestObjectInfo = own new TestObjectInfo();
				}
			}
		/*<??>*/
		
		class Test
		{
			public static void ApplyPackUnpackApplyEquals(NetObject::Object pObjectA, NetObject::Object pObjectB, NetObject::Change pChange)
			{
				Assert::Plz(pChange.Apply(pObjectA));
				
				gsBlob* pBlob = own new gsBlob();
				pChange.Pack(pBlob);
				pBlob.SetOffset(0);

				NetObject::Change* pChangeB = own NetObject::Change::CreateAndUnpack(pBlob);
				Assert::Plz(pChangeB != null);
				Assert::Plz(pChangeB.Apply(pObjectB));
				
				Assert::Plz(pObjectA.IsEqual(pObjectB));
			}

			public static void Run()
			{
				// i'm just reusable stuff for the other change tests!
			}
		}
	}
} 