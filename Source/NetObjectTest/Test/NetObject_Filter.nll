namespace NumbatLogic
{
	namespace NetObject_Filter
	{
		/*<?
			include_once "../../Metaprogramming.php";

			$pOutputArray = array();

			$pObjectChild = new NetObject("Child",
				[
					new NetObjectField("Uint32", "ChildId"),
					new NetObjectField("string", "Name"),
				]
			);
			$pOutputArray[] = $pObjectChild;

			$pObjectParent = new NetObject("Parent",
				[
					new NetObjectField("Uint32", "ParentId"),
					new NetObjectField("Child", "Child"),
					new NetObjectVectorField("Child", "Spawn", array("ChildId")),
					new NetObjectField("Uint32", "Sekrit"),
				]
			);
			$pOutputArray[] = $pObjectParent;

			$pFilterParent = new NetObjectFilter("ParentFilter", "Parent", array(
				"ParentId" => true,
				"Child" => true,
				"Spawn" => array(
					"ChildId" => true
				)
			));
			$pOutputArray[] = $pFilterParent;

			NetObject_Output($pOutputArray, true);
		?>*/
			class disposable ChildInfo : NetObject::ObjectInfo
			{
				public static ChildInfo __pStatic = null;
				public construct() : base(0, 1, 1, 0, 0)
				{
					Assert::Plz(__pStatic == null);
					__pStatic = this;
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::UINT32, "ChildId", 0, 0));
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::STRING, "Name", 1, 0));
				}
				public destruct() { __pStatic = null; }
				public static ChildInfo GetStatic() { Assert::Plz(__pStatic != null); return __pStatic; }
			}

			class Child : NetObject::Object
			{
				public construct(NetObject::Filter pFilter = null) : base(ChildInfo::GetStatic(), pFilter) { }
				public Uint32 GetChildId() { return __GetUint32(0, 0); }
				public string GetName() { return __GetString(1, 0); }
			}

			class disposable ParentInfo : NetObject::ObjectInfo
			{
				public static ParentInfo __pStatic = null;
				public construct() : base(0, 2, 0, 1, 1)
				{
					Assert::Plz(__pStatic == null);
					__pStatic = this;
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::UINT32, "ParentId", 0, 0));
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::OBJECT, "Child", 1, 0));
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::VECTOR, "Spawn", 2, 0));
					__pFieldInfoVector.PushBack(new NetObject::FieldInfo(NetObject::FieldInfo::Type::UINT32, "Sekrit", 3, 1));
				}
				public destruct() { __pStatic = null; }
				public static ParentInfo GetStatic() { Assert::Plz(__pStatic != null); return __pStatic; }
				public override NetObject::Object** __CreateChildObject(int nFieldIndex, NetObject::Filter pFilter)
				{
					switch (nFieldIndex)
					{
						case 1: return new Child();
						case 2: return new Child();
					}
					Assert::Plz(false);
					return null;
				}
			}

			class Parent : NetObject::Object
			{
				public construct(NetObject::Filter pFilter = null) : base(ParentInfo::GetStatic(), pFilter) { }
				public Uint32 GetParentId() { return __GetUint32(0, 0); }
				public Child GetChild() { return cast Child(__GetObject(1, 0)); }
				public int GetNumSpawn() { return __GetVectorSize(2, 0); }
				public Child GetSpawnByIndex(int nIndex) { return cast Child(__GetVectorObject(2, 0, nIndex)); }
				public Child GetSpawnByChildId(Uint32 nChildId) { return cast Child(__GetVectorObjectByUint32(2, 0, 0, nChildId)); }
				public Uint32 GetSekrit() { return __GetUint32(3, 1); }
			}

			class ParentFilter : NetObject::Filter
			{
				public static ParentFilter __pStatic = null;
				public construct() : base(4)
				{
					Assert::Plz(__pStatic == null);
					__pStatic = this;
					__ExposeField(0);
					__ExposeField(1);
					{
						NetObject::Filter p3 = __ExposeFieldCreateFilter(2, 999);
						p3.__ExposeField(0);
					}
				}
				public destruct() { __pStatic = null; }
				public static ParentFilter GetStatic() { Assert::Plz(__pStatic != null); return __pStatic; }
			}

			class disposable NetObjectStatic
			{
				public NetObject::ChangeMap* __pChangeMap;
				public ChildInfo* __pChildInfo;
				public ParentInfo* __pParentInfo;
				public ParentFilter* __pParentFilter;
				public construct()
				{
					__pChangeMap = own new NetObject::ChangeMap();
					__pChildInfo = own new ChildInfo();
					__pParentInfo = own new ParentInfo();
					__pParentFilter = own new ParentFilter();
				}
			}
		/*<??>*/
		
		class Test
		{
			public static void Run()
			{
				NetObjectStatic* pStaticInfo = own new NetObjectStatic();
				Parent* pObjectA = own new Parent(ParentFilter::GetStatic());
				Assert::Plz(pObjectA != null);

				// should fail
				//pObjectA.GetSekrit();

				// todo: pack
				// todo: pack with different filter
				// todo: filter hash
			}
		}
	}
} 