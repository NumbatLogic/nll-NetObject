namespace NumbatLogic
{
	namespace NetObject
	{
		class ObjectInfo
		{
			public int __nNumInt8;
			public int __nNumInt16;
			public int __nNumInt32;
			public int __nNumUint8;
			public int __nNumUint16;
			public int __nNumUint32;
			public int __nNumString;
			public int __nNumObject;
			public int __nNumVector;
			public OwnedVector<FieldInfo>* __pFieldInfoVector;

			public construct(int nNumInt8, int nNumInt16, int nNumInt32, int nNumUint8, int nNumUint16, int nNumUint32, int nNumString, int nNumObject, int nNumVector)
			{
				__nNumInt8 = nNumInt8;
				__nNumInt16 = nNumInt16;
				__nNumInt32 = nNumInt32;
				__nNumUint8 = nNumUint8;
				__nNumUint16 = nNumUint16;
				__nNumUint32 = nNumUint32;
				__nNumString = nNumString;
				__nNumObject = nNumObject;
				__nNumVector = nNumVector;
				__pFieldInfoVector = own new OwnedVector<FieldInfo>();
			}

			public FieldInfo GetFieldInfoByName(string sxName)
			{
				for (int i = 0; i < __pFieldInfoVector.GetSize(); i++)
				{
					FieldInfo pFieldInfo = __pFieldInfoVector.Get(i);
					if (pFieldInfo.__sName.IsEqual(sxName))
						return pFieldInfo;
				}
				return null;
			}

			public FieldInfo GetFieldInfoByNameAndType(string sxName, FieldInfo::Type eType)
			{
				FieldInfo pFieldInfo = GetFieldInfoByName(sxName);
				if (pFieldInfo != null && pFieldInfo.__eType == eType)
					return pFieldInfo;
				return null;
			}

			public virtual Object** __CreateChildObject(int nFieldIndex, Filter pFilter)
			{
				Assert::Plz(false);
				return null;
			}
		}
	}
}