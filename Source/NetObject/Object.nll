namespace NumbatLogic
{
	namespace NetObject
	{
		class Object
		{
			public ObjectInfo __pInfo;
			public Filter __pFilter;

			// todo: NLL needs fixed array tech...
			public Vector<Int8>* __pInt8Vector;
			public Vector<Int16>* __pInt16Vector;
			public Vector<Int32>* __pInt32Vector;
			public Vector<Uint8>* __pUint8Vector;
			public Vector<Uint16>* __pUint16Vector;
			public Vector<Uint32>* __pUint32Vector;
			public Vector<float>* __pFloatVector;
			public OwnedVector<InternalString>* __pStringVector;
			public OwnedVector<Object>* __pObjectVector;
			public OwnedVector<OwnedVector<Object>!>* __pVectorVector;

			public construct(ObjectInfo pInfo, Filter pFilter)
			{
				__pInfo = pInfo;
				__pFilter = pFilter;
				if (__pInfo.__nNumInt8 > 0)
				{
					__pInt8Vector = own new Vector<Int8>();
					for (int i = 0; i < __pInfo.__nNumInt8; i++)
						__pInt8Vector.PushBack(0);
				}
				if (__pInfo.__nNumInt16 > 0)
				{
					__pInt16Vector = own new Vector<Int16>();
					for (int i = 0; i < __pInfo.__nNumInt16; i++)
						__pInt16Vector.PushBack(0);
				}
				if (__pInfo.__nNumInt32 > 0)
				{
					__pInt32Vector = own new Vector<Int32>();
					for (int i = 0; i < __pInfo.__nNumInt32; i++)
						__pInt32Vector.PushBack(0);
				}
				if (__pInfo.__nNumUint8 > 0)
				{
					__pUint8Vector = own new Vector<Uint8>();
					for (int i = 0; i < __pInfo.__nNumUint8; i++)
						__pUint8Vector.PushBack(0);
				}
				if (__pInfo.__nNumUint16 > 0)
				{
					__pUint16Vector = own new Vector<Uint16>();
					for (int i = 0; i < __pInfo.__nNumUint16; i++)
						__pUint16Vector.PushBack(0);
				}
				if (__pInfo.__nNumUint32 > 0)
				{
					__pUint32Vector = own new Vector<Uint32>();
					for (int i = 0; i < __pInfo.__nNumUint32; i++)
						__pUint32Vector.PushBack(0);
				}
				if (__pInfo.__nNumFloat > 0)
				{
					__pFloatVector = own new Vector<float>();
					for (int i = 0; i < __pInfo.__nNumFloat; i++)
						__pFloatVector.PushBack(0.0f);
				}
				if (__pInfo.__nNumString > 0)
				{
					__pStringVector = own new OwnedVector<InternalString>();
					for (int i = 0; i < __pInfo.__nNumString; i++)
						__pStringVector.PushBack(null);
				}
				if (__pInfo.__nNumObject > 0)
				{
					__pObjectVector = own new OwnedVector<Object>();
					for (int i = 0; i < __pInfo.__nNumObject; i++)
						__pObjectVector.PushBack(null);
				}
				if (__pInfo.__nNumVector > 0)
				{
					__pVectorVector = own new OwnedVector<OwnedVector<Object>!>();
					for (int i = 0; i < __pInfo.__nNumVector; i++)
						__pVectorVector.PushBack(null);
				}
			}

			// todo: filter
			// todo: pack checksum
			public void Pack(gsBlob pBlob)
			{
				for (int i = 0; i < __pInfo.__pFieldInfoVector.GetSize(); i++)
				{
					FieldInfo pInfo = __pInfo.__pFieldInfoVector.Get(i);
					switch (pInfo.__eType)
					{
						case FieldInfo::Type::INT8:
						{
							pBlob.PackInt8(__pInt8Vector.Get(pInfo.__nDataIndex));
							break;
						}
						case FieldInfo::Type::INT16:
						{
							pBlob.PackInt16(__pInt16Vector.Get(pInfo.__nDataIndex));
							break;
						}
						case FieldInfo::Type::INT32:
						{
							pBlob.PackInt32(__pInt32Vector.Get(pInfo.__nDataIndex));
							break;
						}
						case FieldInfo::Type::UINT8:
						{
							pBlob.PackUint8(__pUint8Vector.Get(pInfo.__nDataIndex));
							break;
						}
						case FieldInfo::Type::UINT16:
						{
							pBlob.PackUint16(__pUint16Vector.Get(pInfo.__nDataIndex));
							break;
						}
						case FieldInfo::Type::UINT32:
						{
							pBlob.PackUint32(__pUint32Vector.Get(pInfo.__nDataIndex));
							break;
						}
						case FieldInfo::Type::FLOAT:
						{
							pBlob.PackFloat(__pFloatVector.Get(pInfo.__nDataIndex));
							break;
						}
						case FieldInfo::Type::STRING:
						{
							InternalString sTemp = __pStringVector.Get(pInfo.__nDataIndex);
							if (sTemp == null)
							{
								pBlob.PackUint8(0);
							}
							else
							{
								pBlob.PackUint8(1); // todo: excess byte!
								pBlob.PackInternalString(sTemp);
							}
							break;
						}
						case FieldInfo::Type::OBJECT:
						{
							Object pObject = __pObjectVector.Get(pInfo.__nDataIndex);
							if (pObject == null)
							{
								pBlob.PackUint8(0);
							}
							else
							{
								pBlob.PackUint8(1);
								pObject.Pack(pBlob);
							}
							break;
						}
						case FieldInfo::Type::VECTOR:
						{
							OwnedVector<Object> pVector = __pVectorVector.Get(pInfo.__nDataIndex);
							if (pVector == null)
							{
								pBlob.PackUint16(0);
							}
							else
							{
								pBlob.PackUint16(cast Uint16(pVector.GetSize()));
								for (int j = 0; j < pVector.GetSize(); j++)
								{
									Object pObject = pVector.Get(j);
									pObject.Pack(pBlob);
								}
							}
							break;
						}
						default:
						{
							Assert::Plz(false);
							break;
						}
					}
				}
			}

			public bool Unpack(gsBlob pBlob)
			{
				for (int i = 0; i < __pInfo.__pFieldInfoVector.GetSize(); i++)
				{
					FieldInfo pInfo = __pInfo.__pFieldInfoVector.Get(i);
					switch (pInfo.__eType)
					{
						case FieldInfo::Type::INT8:
						{
							Int8 n;
							if (!pBlob.UnpackInt8(ref n))
								return false;
							__pInt8Vector.Set(pInfo.__nDataIndex, n);
							break;
						}
						case FieldInfo::Type::INT16:
						{
							Int16 n;
							if (!pBlob.UnpackInt16(ref n))
								return false;
							__pInt16Vector.Set(pInfo.__nDataIndex, n);
							break;
						}
						case FieldInfo::Type::INT32:
						{
							Int32 n;
							if (!pBlob.UnpackInt32(ref n))
								return false;
							__pInt32Vector.Set(pInfo.__nDataIndex, n);
							break;
						}
						case FieldInfo::Type::UINT8:
						{
							Uint8 n;
							if (!pBlob.UnpackUint8(ref n))
								return false;
							__pUint8Vector.Set(pInfo.__nDataIndex, n);
							break;
						}
						case FieldInfo::Type::UINT16:
						{
							Uint16 n;
							if (!pBlob.UnpackUint16(ref n))
								return false;
							__pUint16Vector.Set(pInfo.__nDataIndex, n);
							break;
						}
						case FieldInfo::Type::UINT32:
						{
							Uint32 n;
							if (!pBlob.UnpackUint32(ref n))
								return false;
							__pUint32Vector.Set(pInfo.__nDataIndex, n);
							break;
						}
						case FieldInfo::Type::FLOAT:
						{
							float n;
							if (!pBlob.UnpackFloat(ref n))
								return false;
							__pFloatVector.Set(pInfo.__nDataIndex, n);
							break;
						}
						case FieldInfo::Type::STRING:
						{
							Uint8 nFlag;
							if (!pBlob.UnpackUint8(ref nFlag))
								return false;
							
							InternalString sTemp = __pStringVector.Get(pInfo.__nDataIndex);
							if (nFlag == 0)
							{
								if (sTemp != null)
								{
									// todo: not very performant over just setting to null in place!!!
									__pStringVector.Erase(pInfo.__nDataIndex);
									__pStringVector.Insert(pInfo.__nDataIndex, null);
								}
							}
							else
							{
								if (sTemp == null)
								{
									InternalString* sOwned = own new InternalString("");
									sTemp = sOwned;
									__pStringVector.Set(pInfo.__nDataIndex, disown sOwned);
								}

								if (!pBlob.UnpackInternalString(sTemp))
									return false;
							}
							break;
						}
						case FieldInfo::Type::OBJECT:
						{
							Uint8 nFlag;
							if (!pBlob.UnpackUint8(ref nFlag))
								return false;
							
							Object pObject = __pObjectVector.Get(pInfo.__nDataIndex);
							if (nFlag == 0)
							{
								if (pObject != null)
								{
									// todo: not very performant over just setting to null in place!!!
									__pObjectVector.Erase(pInfo.__nDataIndex);
									__pObjectVector.Insert(pInfo.__nDataIndex, null);
								}
							}
							else
							{
								if (pObject == null)
								{
									Object* pOwned = own __pInfo.__CreateChildObject(i, __pFilter);
									pObject = pOwned;
									__pObjectVector.Set(pInfo.__nDataIndex, disown pOwned);
								}

								if (!pObject.Unpack(pBlob))
									return false;
							}
							break;
						}
						case FieldInfo::Type::VECTOR:
						{
							Uint16 nSize;
							if (!pBlob.UnpackUint16(ref nSize))
								return false;
							
							OwnedVector<Object> pVector = __pVectorVector.Get(pInfo.__nDataIndex);
							if (nSize == 0)
							{
								if (pVector != null)
									pVector.Clear();
							}
							else
							{
								if (pVector == null)
								{
									OwnedVector<Object>* pOwnedVector = own new OwnedVector<Object>();
									pVector = pOwnedVector;
									__pVectorVector.Set(pInfo.__nDataIndex, disown pOwnedVector);
								}
								pVector.Clear();

								for (Uint16 j = 0; j < nSize; j++)
								{
									Object* pOwned = own __pInfo.__CreateChildObject(i, __pFilter);
									if (!pOwned.Unpack(pBlob))
										return false;
									pVector.PushBack(disown pOwned);
								}
							}
							break;
						}
						default:
						{
							Assert::Plz(false);
							break;
						}
					}
				}
				return true;
			}

			// filter???
			public bool IsEqual(Object pOther)
			{
				Assert::Plz(__pInfo == pOther.__pInfo);

				for (int i = 0; i < __pInfo.__nNumInt8; i++)
					if (__pInt8Vector.Get(i) != pOther.__pInt8Vector.Get(i))
						return false;
						
				for (int i = 0; i < __pInfo.__nNumInt16; i++)
					if (__pInt16Vector.Get(i) != pOther.__pInt16Vector.Get(i))
						return false;

				for (int i = 0; i < __pInfo.__nNumInt32; i++)
					if (__pInt32Vector.Get(i) != pOther.__pInt32Vector.Get(i))
						return false;

				for (int i = 0; i < __pInfo.__nNumUint8; i++)
					if (__pUint8Vector.Get(i) != pOther.__pUint8Vector.Get(i))
						return false;

				for (int i = 0; i < __pInfo.__nNumUint16; i++)
					if (__pUint16Vector.Get(i) != pOther.__pUint16Vector.Get(i))
						return false;

				for (int i = 0; i < __pInfo.__nNumUint32; i++)
					if (__pUint32Vector.Get(i) != pOther.__pUint32Vector.Get(i))
						return false;

				for (int i = 0; i < __pInfo.__nNumFloat; i++)
					if (__pFloatVector.Get(i) != pOther.__pFloatVector.Get(i))
						return false;

				for (int i = 0; i < __pInfo.__nNumString; i++)
				{
					InternalString sTemp = __pStringVector.Get(i);
					InternalString sOther = pOther.__pStringVector.Get(i);

					if (sTemp == null || sTemp.IsEqual(""))
					{
						if (sOther != null && !sOther.IsEqual(""))
							return false;
					}
					else
					{
						if (sOther == null || !sTemp.IsEqual(sOther.GetExternalString()))
							return false;
					}
				}

				for (int i = 0; i < __pInfo.__nNumObject; i++)
				{
					Object pA = __pObjectVector.Get(i);
					Object pB = pOther.__pObjectVector.Get(i);

					if (pA == null)
					{
						if (pB != null)
							return false;
					}
					else
					{
						if (pB == null || !pA.IsEqual(pB))
							return false;
					}
				}

				for (int i = 0; i < __pInfo.__nNumVector; i++)
				{
					OwnedVector<Object> pVectorA = __pVectorVector.Get(i);
					OwnedVector<Object> pVectorB = pOther.__pVectorVector.Get(i);

					if (pVectorA == null || pVectorA.GetSize() == 0)
					{
						if (pVectorB != null && pVectorB.GetSize() > 0)
							return false;
					}
					else
					{
						if (pVectorA.GetSize() != pVectorB.GetSize())
							return false;

						for (int j = 0; j < pVectorA.GetSize(); j++)
						{
							Object pA = pVectorA.Get(j);
							Object pB = pVectorB.Get(j);
							if (pA == null)
							{
								if (pB != null)
									return false;
							}
							else if (pB == null || !pA.IsEqual(pB))
							{
								return false;
							}
						}
					}
				}
				
				return true;
			}

			// todo: filter and range check!
			public Int8 __GetInt8(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				return __pInt8Vector.Get(nDataIndex);
			}

			public Int16 __GetInt16(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				return __pInt16Vector.Get(nDataIndex);
			}

			public Int32 __GetInt32(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				return __pInt32Vector.Get(nDataIndex);
			}

			public Uint8 __GetUint8(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				return __pUint8Vector.Get(nDataIndex);
			}

			public Uint16 __GetUint16(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				return __pUint16Vector.Get(nDataIndex);
			}

			public Uint32 __GetUint32(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				return __pUint32Vector.Get(nDataIndex);
			}

			public float __GetFloat(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				return __pFloatVector.Get(nDataIndex);
			}

			public string __GetString(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				InternalString sTemp = __pStringVector.Get(nDataIndex);
				if (sTemp == null)
					return "";
				return sTemp.GetExternalString();
			}

			public void __SetString(Uint8 nFieldIndex, Uint8 nDataIndex, string sxString)
			{
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				InternalString sTemp = __pStringVector.Get(nDataIndex);
				if (sTemp == null)
				{
					InternalString* sOwned = own new InternalString(sxString);
					__pStringVector.Set(nDataIndex, disown sOwned);
					return;
				}
				sTemp.Set(sxString);
			}

			public Object __GetObject(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				return __pObjectVector.Get(nDataIndex);
			}

			public int __GetVectorSize(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);
				if (pVector == null)
					return 0;
				return pVector.GetSize();
			}

			public Object __GetVectorObject(Uint8 nFieldIndex, Uint8 nDataIndex, int nVectorIndex)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);
				Assert::Plz(pVector != null);
				Assert::Plz(nVectorIndex >= 0);
				Assert::Plz(nVectorIndex <= pVector.GetSize());
				
				return pVector.Get(nVectorIndex);
			}

			public Object __GetVectorObjectByInt8(Uint8 nFieldIndex, Uint8 nDataIndex, int nVectorObjectDataIndex, Int8 nValue)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);
				// todo: filter check (before vector check?)

				if (pVector != null)
				{
					for (int i = 0; i < pVector.GetSize(); i++)
					{
						Object pVectorObject = pVector.Get(i);
						if (pVectorObject.__pInt8Vector.Get(nVectorObjectDataIndex) == nValue)
							return pVectorObject;
					}
				}
				return null;
			}

			public Object __GetVectorObjectByInt16(Uint8 nFieldIndex, Uint8 nDataIndex, int nVectorObjectDataIndex, Int16 nValue)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);
				// todo: filter check (before vector check?)

				if (pVector != null)
				{
					for (int i = 0; i < pVector.GetSize(); i++)
					{
						Object pVectorObject = pVector.Get(i);
						if (pVectorObject.__pInt16Vector.Get(nVectorObjectDataIndex) == nValue)
							return pVectorObject;
					}
				}
				return null;
			}

			public Object __GetVectorObjectByInt32(Uint8 nFieldIndex, Uint8 nDataIndex, int nVectorObjectDataIndex, Int32 nValue)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);
				// todo: filter check (before vector check?)

				if (pVector != null)
				{
					for (int i = 0; i < pVector.GetSize(); i++)
					{
						Object pVectorObject = pVector.Get(i);
						if (pVectorObject.__pInt32Vector.Get(nVectorObjectDataIndex) == nValue)
							return pVectorObject;
					}
				}
				return null;
			}

			public Object __GetVectorObjectByUint8(Uint8 nFieldIndex, Uint8 nDataIndex, int nVectorObjectDataIndex, Uint8 nValue)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);
				// todo: filter check (before vector check?)

				if (pVector != null)
				{
					for (int i = 0; i < pVector.GetSize(); i++)
					{
						Object pVectorObject = pVector.Get(i);
						if (pVectorObject.__pUint8Vector.Get(nVectorObjectDataIndex) == nValue)
							return pVectorObject;
					}
				}
				return null;
			}

			public Object __GetVectorObjectByUint16(Uint8 nFieldIndex, Uint8 nDataIndex, int nVectorObjectDataIndex, Uint16 nValue)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);
				// todo: filter check (before vector check?)

				if (pVector != null)
				{
					for (int i = 0; i < pVector.GetSize(); i++)
					{
						Object pVectorObject = pVector.Get(i);
						if (pVectorObject.__pUint16Vector.Get(nVectorObjectDataIndex) == nValue)
							return pVectorObject;
					}
				}
				return null;
			}

			public Object __GetVectorObjectByUint32(Uint8 nFieldIndex, Uint8 nDataIndex, int nVectorObjectDataIndex, Uint32 nValue)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);
				// todo: filter check (before vector check?)

				if (pVector != null)
				{
					for (int i = 0; i < pVector.GetSize(); i++)
					{
						Object pVectorObject = pVector.Get(i);
						if (pVectorObject.__pUint32Vector.Get(nVectorObjectDataIndex) == nValue)
							return pVectorObject;
					}
				}
				return null;
			}

			public Object __GetVectorObjectByFloat(Uint8 nFieldIndex, Uint8 nDataIndex, int nVectorObjectDataIndex, float fValue)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);
				// todo: filter check (before vector check?)

				if (pVector != null)
				{
					for (int i = 0; i < pVector.GetSize(); i++)
					{
						Object pVectorObject = pVector.Get(i);
						if (pVectorObject.__pFloatVector.Get(nVectorObjectDataIndex) == fValue)
							return pVectorObject;
					}
				}
				return null;
			}

			public Object __GetVectorObjectByString(Uint8 nFieldIndex, Uint8 nDataIndex, int nVectorObjectDataIndex, string sxValue)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);

				// todo: filter check

				if (pVector != null)
				{
					for (int i = 0; i < pVector.GetSize(); i++)
					{
						Object pVectorObject = pVector.Get(i);
						InternalString sTemp = pVectorObject.__pStringVector.Get(nVectorObjectDataIndex);
						if (sTemp == null)
						{
							if (sxValue == null || ExternalString::Equal(sxValue, ""))
								return pVectorObject;
						}
						else if (sTemp.IsEqual(sxValue))
						{
							return pVectorObject;
						}
					}
				}
				return null;
			}

			public bool __VectorPushBack(Uint8 nFieldIndex, Uint8 nDataIndex, Object** pObject)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);
				if (pVector == null)
				{
					__pVectorVector.Set(nDataIndex, new OwnedVector<Object>());
					pVector = __pVectorVector.Get(nDataIndex);
				}
				pVector.PushBack(pObject);

				return true;
			}
		}
	}
}