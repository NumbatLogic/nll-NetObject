namespace NumbatLogic
{
	namespace NetObject
	{
		class Object
		{
			public ObjectInfo __pInfo;
			public Filter __pFilter;

			// todo: NLL needs fixed array tech...
			public Vector<Uint32>* __pUint32Vector;
			public OwnedVector<InternalString>* __pStringVector;
			public OwnedVector<Object>* __pObjectVector;
			public OwnedVector<OwnedVector<Object>!>* __pVectorVector;

			public construct(ObjectInfo pInfo, Filter pFilter)
			{
				__pInfo = pInfo;
				__pFilter = pFilter;
				if (__pInfo.__nNumUint32 > 0)
				{
					__pUint32Vector = own new Vector<Uint32>();
					for (int i = 0; i < __pInfo.__nNumUint32; i++)
						__pUint32Vector.PushBack(0);
				}
				if (__pInfo.__nNumString > 0)
				{
					__pStringVector = own new OwnedVector<InternalString>();
					for (int i = 0; i < __pInfo.__nNumString; i++)
						__pStringVector.PushBack(null);
				}
				if (__pInfo.__nNumObject > 0)
				{
					__pObjectVector = own new OwnedVector<Object>();
					for (int i = 0; i < __pInfo.__nNumObject; i++)
						__pObjectVector.PushBack(null);
				}
				if (__pInfo.__nNumVector > 0)
				{
					__pVectorVector = own new OwnedVector<OwnedVector<Object>!>();
					for (int i = 0; i < __pInfo.__nNumVector; i++)
						__pVectorVector.PushBack(null);
				}
			}

			// todo: filter
			// todo: pack checksum
			public void Pack(gsBlob pBlob)
			{
				for (int i = 0; i < __pInfo.__pFieldInfoVector.GetSize(); i++)
				{
					FieldInfo pInfo = __pInfo.__pFieldInfoVector.Get(i);
					switch (pInfo.__eType)
					{
						case FieldInfo::Type::UINT32:
						{
							pBlob.PackUint32(__pUint32Vector.Get(pInfo.__nDataIndex));
							break;
						}
						case FieldInfo::Type::STRING:
						{
							InternalString sTemp = __pStringVector.Get(pInfo.__nDataIndex);
							if (sTemp == null)
							{
								pBlob.PackUint8(0);
							}
							else
							{
								pBlob.PackUint8(1); // todo: excess byte!
								pBlob.PackInternalString(sTemp);
							}
							break;
						}
						case FieldInfo::Type::OBJECT:
						{
							Object pObject = __pObjectVector.Get(pInfo.__nDataIndex);
							if (pObject == null)
							{
								pBlob.PackUint8(0);
							}
							else
							{
								pBlob.PackUint8(1);
								pObject.Pack(pBlob);
							}
							break;
						}
						case FieldInfo::Type::VECTOR:
						{
							OwnedVector<Object> pVector = __pVectorVector.Get(pInfo.__nDataIndex);
							if (pVector == null)
							{
								pBlob.PackUint16(0);
							}
							else
							{
								pBlob.PackUint16(pVector.GetSize());
								for (int j = 0; j < pVector.GetSize(); j++)
								{
									Object pObject = pVector.Get(j);
									pObject.Pack(pBlob);
								}
							}
							break;
						}
						default:
						{
							Assert::Plz(false);
						}
					}
				}
			}

			public bool Unpack(gsBlob pBlob)
			{
				for (int i = 0; i < __pInfo.__pFieldInfoVector.GetSize(); i++)
				{
					FieldInfo pInfo = __pInfo.__pFieldInfoVector.Get(i);
					switch (pInfo.__eType)
					{
						case FieldInfo::Type::UINT32:
						{
							Uint32 n;
							if (!pBlob.UnpackUint32(n))
								return false;
							__pUint32Vector.Set(pInfo.__nDataIndex, n);
							break;
						}
						case FieldInfo::Type::STRING:
						{
							Uint8 nFlag;
							if (!pBlob.UnpackUint8(nFlag))
								return false;
							
							InternalString sTemp = __pStringVector.Get(pInfo.__nDataIndex);
							if (nFlag == 0)
							{
								if (sTemp != null)
								{
									// todo: not very performant over just setting to null in place!!!
									__pStringVector.Erase(pInfo.__nDataIndex);
									__pStringVector.Insert(pInfo.__nDataIndex, null);
								}
							}
							else
							{
								if (sTemp == null)
								{
									InternalString* sOwned = own new InternalString("");
									sTemp = sOwned;
									__pStringVector.Set(pInfo.__nDataIndex, disown sOwned);
								}

								if (!pBlob.UnpackInternalString(sTemp))
									return false;
							}
							break;
						}
						case FieldInfo::Type::OBJECT:
						{
							Uint8 nFlag;
							if (!pBlob.UnpackUint8(nFlag))
								return false;
							
							Object pObject = __pObjectVector.Get(pInfo.__nDataIndex);
							if (nFlag == 0)
							{
								if (pObject != null)
								{
									// todo: not very performant over just setting to null in place!!!
									__pObjectVector.Erase(pInfo.__nDataIndex);
									__pObjectVector.Insert(pInfo.__nDataIndex, null);
								}
							}
							else
							{
								if (pObject == null)
								{
									Object* pOwned = own __pInfo.__CreateChildObject(i, __pFilter);
									pObject = pOwned;
									__pObjectVector.Set(pInfo.__nDataIndex, disown pOwned);
								}

								if (!pObject.Unpack(pBlob))
									return false;
							}
							break;
						}
						case FieldInfo::Type::VECTOR:
						{
							Uint16 nSize;
							if (!pBlob.UnpackUint16(nSize))
								return false;
							
							OwnedVector<Object> pVector = __pVectorVector.Get(pInfo.__nDataIndex);
							if (nSize == 0)
							{
								if (pVector != null)
									pVector.Clear();
							}
							else
							{
								if (pVector == null)
								{
									OwnedVector<Object>* pOwnedVector = own new OwnedVector<Object>();
									pVector = pOwnedVector;
									__pVectorVector.Set(pInfo.__nDataIndex, disown pOwnedVector);
								}
								pVector.Clear();

								for (Uint16 j = 0; j < nSize; j++)
								{
									Object* pOwned = own __pInfo.__CreateChildObject(i, __pFilter);
									if (!pOwned.Unpack(pBlob))
										return false;
									pVector.PushBack(disown pOwned);
								}
							}
							break;
						}
						default:
						{
							Assert::Plz(false);
						}
					}
				}
				return true;
			}

			// filter???
			public bool IsEqual(Object pOther)
			{
				Assert::Plz(__pInfo == pOther.__pInfo);

				for (int i = 0; i < __pInfo.__nNumUint32; i++)
					if (__pUint32Vector.Get(i) != pOther.__pUint32Vector.Get(i))
						return false;

				for (int i = 0; i < __pInfo.__nNumString; i++)
				{
					InternalString sTemp = __pStringVector.Get(i);
					InternalString sOther = pOther.__pStringVector.Get(i);

					if (sTemp == null || sTemp.IsEqual(""))
					{
						if (sOther != null && !sOther.IsEqual(""))
							return false;
					}
					else
					{
						if (sOther == null || !sTemp.IsEqual(sOther.GetExternalString()))
							return false;
					}
				}

				for (int i = 0; i < __pInfo.__nNumObject; i++)
				{
					Object pA = __pObjectVector.Get(i);
					Object pB = pOther.__pObjectVector.Get(i);

					if (pA == null)
					{
						if (pB != null)
							return false;
					}
					else
					{
						if (pB == null || !pA.IsEqual(pB))
							return false;
					}
				}

				for (int i = 0; i < __pInfo.__nNumVector; i++)
				{
					OwnedVector<Object> pVectorA = __pVectorVector.Get(i);
					OwnedVector<Object> pVectorB = pOther.__pVectorVector.Get(i);

					if (pVectorA == null || pVectorA.GetSize() == 0)
					{
						if (pVectorB != null && pVectorB.GetSize() > 0)
							return false;
					}
					else
					{
						if (pVectorA.GetSize() != pVectorB.GetSize())
							return false;

						for (int j = 0; j < pVectorA.GetSize(); j++)
						{
							Object pA = pVectorA.Get(j);
							Object pB = pVectorB.Get(j);
							if (pA == null)
							{
								if (pB != null)
									return false;
							}
							else if (pB == null || !pA.IsEqual(pB))
							{
								return false;
							}
						}
					}
				}
				
				return true;
			}

			// todo: filter and range check!
			public Uint32 __GetUint32(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				return __pUint32Vector.Get(nDataIndex);
			}

			public string __GetString(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				InternalString sTemp = __pStringVector.Get(nDataIndex);
				if (sTemp == null)
					return "";
				return sTemp.GetExternalString();
			}

			public void __SetString(Uint8 nFieldIndex, Uint8 nDataIndex, string sxString)
			{
				Console::Log(sxString);
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				InternalString sTemp = __pStringVector.Get(nDataIndex);
				if (sTemp == null)
				{
					InternalString* sOwned = own new InternalString(sxString);
					__pStringVector.Set(nDataIndex, disown sOwned);
					return;
				}
				sTemp.Set(sxString);
			}

			public Object __GetObject(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				Assert::Plz(__pFilter == null || __pFilter.__bExposeFieldVector.Get(nFieldIndex));
				return __pObjectVector.Get(nDataIndex);
			}

			public int __GetVectorSize(Uint8 nFieldIndex, Uint8 nDataIndex)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);
				if (pVector == null)
					return 0;
				return pVector.GetSize();
			}

			public Object __GetVectorObject(Uint8 nFieldIndex, Uint8 nDataIndex, int nVectorIndex)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);
				Assert::Plz(pVector != null);
				Assert::Plz(nVectorIndex >= 0);
				Assert::Plz(nVectorIndex <= pVector.GetSize());
				
				return pVector.Get(nVectorIndex);
			}

			public Object __GetVectorObjectByUint32(Uint8 nFieldIndex, Uint8 nDataIndex, int nVectorObjectDataIndex, Uint32 nValue)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);
				// todo: filter check (before vector check?)

				if (pVector != null)
				{
					for (int i = 0; i < pVector.GetSize(); i++)
					{
						Object pVectorObject = pVector.Get(i);
						if (pVectorObject.__pUint32Vector.Get(nVectorObjectDataIndex) == nValue)
							return pVectorObject;
					}
				}
				return null;
			}

			public Object __GetVectorObjectByString(Uint8 nFieldIndex, Uint8 nDataIndex, int nVectorObjectDataIndex, string sxValue)
			{
				OwnedVector<Object> pVector = __pVectorVector.Get(nDataIndex);

				// todo: filter check

				if (pVector != null)
				{
					for (int i = 0; i < pVector.GetSize(); i++)
					{
						Object pVectorObject = pVector.Get(i);
						InternalString sTemp = pVectorObject.__pStringVector.Get(nVectorObjectDataIndex);
						if (sTemp == null)
						{
							if (sxValue == null || ExternalString::Equal(sxValue, ""))
								return pVectorObject;
						}
						else if (sTemp.IsEqual(sxValue))
						{
							return pVectorObject;
						}
					}
				}
				return null;
			}
		}
	}
}